#include<iostream>
#include<vector>
#include<bitset>

using namespace std;

template<class T> T bpow (T a, int n) {// функция быстрого возведения в степень, работает за счёт уменьшения количества умножений ( если степень чётная, то это произведение двух чисел 
	// с тем же основанием но с в 2 раза меньшей степенью, для нечётных степенейнужно лишь сделать -1. 
	T res = 1;
	while (n>0)
	{
		if (n % 2 == 1) 
		{
			res *= a;
			n--;
		}
		else 
		{
			a *= a;
			n=n/2;
		}
	}
	return res;
}

int mainprogram (const int n, const int m)// 
{
	int step2n=bpow<int>(2,n);// вычисляем значение 2^n, чтобы знать,  чему должно быть равно число для хранения одного профиля

	vector<vector<bool>> d(step2n);// матрица, в которой будет храниться информация, возможно ли сделать из одного профиля другой

	for (int i=0; i < step2n ; i++)// заполняем матрицу пустыми элементами
	{
		vector<bool> temp(step2n);
		d[i]=temp;
	}

	for (int i=0 ; i < step2n ; i++)//начинаем обход
	{
	for (int j=0 ; j < step2n ; j++)
	{
		vector<bool> temp1;// создаём массивы, для хранения расшифрованых из int профилей
		vector<bool> temp2;

		int int_temp1=i;// временные переменные для расшифровки
		int int_temp2=j;

		for(int k=0 ; k < n ; k++)// процесс расшифровки методом сдвига битов и сканирование каждого с помощью %2
		{
			temp1.push_back(int_temp1%2);
			temp2.push_back(int_temp2%2);

			int_temp1 = int_temp1>>1;
			int_temp2 = int_temp2>>1;
		}

		bool flag=1;// индикатор, возможно ли из 1-го профиля получить 2-ой, по умолчанию правда

		for (int k=0 ; k < n ; k++)// начинаем просматривать профили
		{/*
		 Начинаем обход сверху вниз по столбцу профиля и с помощью второго профиля смотрим какие доминошки должны класться горизнтально
		 */
			if (temp1[k]==1 && temp2[k]==1) flag=0;// если горизонтальная доминошка накладывается на другую (в 1-ом профиле клетка уже занята), то ворвращаем 0, то есть невозможно

			if (temp1[k]==0 && temp2[k]==0)// если клетка в первом профиле свободна, а горизонтальной доминошки там не должно быть, то проверяем возможность положить вертикальную
			{
				if ( k==n-1 ) flag=0;//если пустая клетка последняя в столбце, то вертикальную доминошку нельзя положить, возвращаем 0
				else if ( temp1[k+1]==0 && temp2[k+1]==0 ) k++;// так как 1-ый профиль в итоге должен быть полностью заполнен, то если следующая клетка занята и вертикальную доминошку нельзя положить, то возвращаем 0, иначе 1 и перепрыгиваем через ячейку
					 else { flag=0; k++; }
			}
		}

		d[i][j]=flag;
	}
	}


	vector<vector<int>> mainmass; // создаём матрицу ответов
	vector<int> tempfirst;// первый столбец
	mainmass.push_back(tempfirst);//ложим
	mainmass[0].push_back(1);//первый элемент в нём 1

	for( int k=1 ; k < step2n ; k++)//остальные нули
	{
		mainmass[0].push_back(0);
	}

	for( int k=1 ; k <= m ; k++)// начинаем обход матрицы и динамическое заполнение с помощью...
	{
		vector<int> temp;
		for( int j=0 ; j < step2n ; j++)
		{
			int result=0;
			for (int i=0 ; i < step2n ; i++)
			{
				result=result + mainmass[k-1][i]*d[i][j];// ... этой формулы
			}
			
			temp.push_back(result);
			
		}

		mainmass.push_back(temp);
	}

	return mainmass[m][0];// в m+1 столбце(вектор нумирует с 0) будет лежать ответ.
}

int recursion(int y, int x, vector< vector<bool> > mass)
	/*
	Рекурсивная функция для программы теста. Работает простым обходом вариантов и их подсчётом. Начинает с левого верхнего угла - координаты (0,0) 
	и далее идёт вниз (на увеличение y) , пока не встретит конец поля, от туда перескакивает на следующий столбец (x+1) и снова проходит его.
	Так происходит до момента, пока не окажется в конечных координатах. Если что-то пошло не так, сразу возвращает 0 вне зависимости от местоположения.
	*/
{
	if ( y == mass.size()-1 )// проверки для случая, когда мы добрались до 'нижнего' края поля
	{
		if ( x == mass[0].size()-1 ) // если мы в 'правом нижнем' краю, то проверяем, если поле заполнено, то всё прошло хорошо и возвращаем 1, иначе поле не может быть полностью заполнено и возвращаем 0
		{
			if ( mass[y][x]==0 ) return 0;
			else return 1;
		}

		else // если мы просто дошли до нижнего края одного из столбцов, то если клетка свободна, ложим горизонтальную доминошку, иначе начинаем рассматривать следующий столбец
		{
			if (mass[y][x] == 1 ) return recursion( 0 , x+1 , mass);
			else 
			{
				mass[y][x]=1;
				mass[y][x+1]=1;
				return recursion( 0 , x+1 , mass);
			}
		}
	}

	else if ( x == mass[0].size()-1 )// если мы дошли до последнего столбца, то начинаем пытаться уложить его вертикальными доминошками: если клетка занята, переходим
		// к следующей, если свободна, то рассматриваем следующую. Если следующая клетка тоже свободна, то ложим вертикальную доминошку и идём дальше, иначе возвращаем 0
	{
		if ( mass [y][x] == 1 ) return recursion ( y+1, x, mass);
		else if ( mass [y+1][x] == 1 ) return 0;
		else 
		{
			mass [y][x]=1;
			mass [y+1][x]=1;
			return recursion ( y+1, x, mass);
		}
	}

	else // теперь рассматриваем вариант, когда мы не стоим у нижнего или правого края поля
	{
		if ( mass [y][x] == 1 ) return recursion ( y+1, x, mass);// если ячейка заполнена, то переходим к следующей
		else if (mass[y+1][x] == 1 )
			// если ячейка пуста, то проверяем следующую ячейку. Если следующая ячейка заполнена ( вариант, когда мы положили горизонтальную в предыдущем столбце)
			// то мы ложим только горизонтальную доминошку и идём дальше
		{
			mass[y][x] = 1;
			mass[y][x+1] = 1;
			return recursion ( y+1, x, mass);
		}
		else 
		{
			//если же обе ячейки пусты (данная и нижняя), то заполняем ячейку, в которой мы находимся, копируем массив ячеек и
			mass[y][x] = 1;

			vector< vector<bool> > masscopy(mass.size());

			for (int k=0 ; k < mass.size() ; k++)
			{
				vector<bool> temp(mass[0].size());

				for (int j=0 ; j < mass[0].size() ; j++)
				{
					temp[j]=mass[k][j];
				}

				masscopy[k]=temp;
			}
			// и для каждого массива создаём 2 варианта, для первого ложим вертикальную доминошку, для второго горизонтальную
			mass[y+1][x] = 1;
			masscopy[y][x+1] = 1;
			return recursion ( y+1, x, mass) + recursion ( y+1, x, masscopy);// после чего вызываем рекурсию для них обоих
		}
	}
}

int testprogram (const int n, const int m)// программа, которая высчитывает кол-во вариантов заполнения в лоб, с помощью рекурсии
{
	vector< vector<bool> > mass(n);

	for (int k=0 ; k < n ; k++)// заполняем поле '0', которые означают, что ячейка свободна
	{
		vector<bool> temp(m);
		mass[k]=temp;
	}

	int result=recursion(0 , 0 , mass);// запускаем рекурсию

	return result;
}

void main2() 
{
	int n=0,m=0,main=0,test=0;
	for (n=1 ; n <= 10 ; n++)// обход по разным значениям n,m. При m>5 test начинает сильно тормозить, при n>6 main так-же начинает подтормаживать, но гораздо меньше
	for (m=1 ; m <= 10 ; m++)
	{
		cout<<endl<<n<<", "<<m<<endl;
		main = mainprogram(n,m);
		cout<<"mainprogram............... ok"<<endl;
		test = testprogram(n,m);
		cout<<"testprogram............... ok"<<endl;
		if ( main==test ) cout<<main<<" = "<<test<<" .................. test complet"<<endl;
		else { cout<<main<<" != "<<test<<" .................. test fail"<<endl; break; }
	}

	system("pause");
}